{"status":"ok","feed":{"url":"https://medium.com/feed/@@jaychaturvedi18","title":"Stories by Jay Chaturvedi on Medium","link":"https://medium.com/@jaychaturvedi18?source=rss-74ceb30109d2------2","author":"","description":"Stories by Jay Chaturvedi on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/2*U4hMkdaY0vp-76qxnHCRXQ.jpeg"},"items":[{"title":"How to Secure Your API With JSON Web Tokens in nodejs","pubDate":"2020-10-08 23:46:50","link":"https://medium.com/@jaychaturvedi18/how-to-secure-your-api-with-json-web-tokens-in-nodejs-fb4d71313001?source=rss-74ceb30109d2------2","guid":"https://medium.com/p/fb4d71313001","author":"Jay Chaturvedi","thumbnail":"","description":"\n<p>Tokens are called JWT that stands for JSON Web Tokens. They are one of the major and very easy ways for authenticating a user. The idea is when creating a user or logging in, a token is created and stored client side. This is sent in an Authorization header with every request and the system determines whether the user of that token has authorization to access that endpoint.</p>\n<figure><img alt=\"Token passed as Authorization header while making request to api in postman\" src=\"https://cdn-images-1.medium.com/max/1024/1*oULRURFEeTFWmf8C-CrIEw.png\"></figure><p>Each token is made up of three\u00a0parts:</p>\n<ul>\n<li>\n<strong>header: </strong>contains information about the algorithm and the token\u00a0type</li>\n<li>\n<strong>payload: </strong>contains arbitrary data. Usually, you would store information that identifies the user. Such as an id alongside with an expiration date. This ensures that the token expires over time and cannot be used indefinitely.</li>\n<li>\n<strong>signature: </strong>this is where your token gets generated. It combines a base64 encoded version of your header and payload with a secret key of your\u00a0choice.</li>\n</ul>\n<figure><img alt=\"Generation of JWT token on their official website\" src=\"https://cdn-images-1.medium.com/proxy/1*ni4H_Qg3g_WofUzwS0_huA.gif\"></figure><h3>Authentication vs Authorization</h3>\n<p>Before moving on to coding, we must differentiate between authentication and authorization. While they sound similar, they do not mean the same thing. Authentication means we take a username and a password and check if they are correct. Authorization on the other hand is used for verifying any subsequent request to make sure they are originating from the same user we logged\u00a0in.</p>\n<h3>Middleware</h3>\n<p>To validate a token, the best approach is to write a middleware which do this validation for us and then pass the request to the next request handler if it\u2019s valid, otherwise if a token is not valid\u00a0, the middleware shall throw back some error and stops the execution. <br>We pass this middleware in api routes to make it secure. Lets understand all this with some\u00a0example</p>\n<p>In my case I get JWT token from my AWS Cognito. For those who are not familiar of AWS Cognito, It\u2019s an OAuth strategy provided by aws to authenticate an user and return a token after valid authentication. <br>Every token generated has a life span after which the token is expired and is of no use. In that case user session must be refreshed to get a new\u00a0token.</p>\n<p>Each token have an issue time and expiry time. We can use this time to check if our token is expired our not. Another approach is to cross check the signature of passed token in header with the public key provided by every OAuth strategy (in our case its AWS Cognito) to sign these\u00a0token.</p>\n<h4>Token Validator function</h4>\n<a href=\"https://medium.com/media/1f88473c0f8cb3e5d93747d68b4cbb30/href\">https://medium.com/media/1f88473c0f8cb3e5d93747d68b4cbb30/href</a><p>Above piece of code is called in the below piece of code on line no\u00a09.</p>\n<h4>Secure Middleware (important piece of\u00a0code)</h4>\n<a href=\"https://medium.com/media/f34b3610e058cb6b803e93cca0beb2d5/href\">https://medium.com/media/f34b3610e058cb6b803e93cca0beb2d5/href</a><p>On line 11 we check if our token is invalid, expired and then we throw an error which goes to express error handler and return an response like\u00a0this.</p>\n<pre>{</pre>\n<pre>    \"status\": \"ERROR\",</pre>\n<pre>    \"error\": {</pre>\n<pre>        \"code\": 400,</pre>\n<pre>        \"name\": \"BAD_REQUEST_ERROR\",</pre>\n<pre>        \"message\": \"Expired token\"</pre>\n<pre>    },</pre>\n<pre>    \"date\": \"2020-10-08T23:21:48.508Z\"</pre>\n<pre>}</pre>\n<p>If a token is valid and not expired then we can proceed with decoding the token (on line 15). Our decoded token will have fields like\u00a0this.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/433/1*pL1tiQnXz7kQrC9dIl6Agw.png\"><figcaption>decoded JWT\u00a0token</figcaption></figure><p>After everything successfully done we can either attach these fields in our response body and pass it to our api routes which will use these key value of token or we can directly call next() to pass our next request handler which are api routes in our\u00a0case.</p>\n<p>Now comes the final phase which is attaching our Secure Middleware in our api\u00a0routes.</p>\n<pre>app.get('/', secureMiddleware,</pre>\n<pre>    async (req: Request, res: Response, next: NextFunction) =&gt; {</pre>\n<pre>    const user = res.locals.user //this comes from our<br>                                 //secure middleware(on line 16)</pre>\n<pre>    res.json(user)</pre>\n<pre>    }<br>)</pre>\n<p>Finally we have made our api routes secure which will not only protects our api from unauthorized users but will also check for token\u2019s expiry to make it more secure from session hijacking.</p>\n<p>There will be a part2 of this article where we will see how to restrict access to our routes according to Users role (eg. Admin, Customer, Developer etc.)</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=fb4d71313001\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Tokens are called JWT that stands for JSON Web Tokens. They are one of the major and very easy ways for authenticating a user. The idea is when creating a user or logging in, a token is created and stored client side. This is sent in an Authorization header with every request and the system determines whether the user of that token has authorization to access that endpoint.</p>\n<figure><img alt=\"Token passed as Authorization header while making request to api in postman\" src=\"https://cdn-images-1.medium.com/max/1024/1*oULRURFEeTFWmf8C-CrIEw.png\"></figure><p>Each token is made up of three\u00a0parts:</p>\n<ul>\n<li>\n<strong>header: </strong>contains information about the algorithm and the token\u00a0type</li>\n<li>\n<strong>payload: </strong>contains arbitrary data. Usually, you would store information that identifies the user. Such as an id alongside with an expiration date. This ensures that the token expires over time and cannot be used indefinitely.</li>\n<li>\n<strong>signature: </strong>this is where your token gets generated. It combines a base64 encoded version of your header and payload with a secret key of your\u00a0choice.</li>\n</ul>\n<figure><img alt=\"Generation of JWT token on their official website\" src=\"https://cdn-images-1.medium.com/proxy/1*ni4H_Qg3g_WofUzwS0_huA.gif\"></figure><h3>Authentication vs Authorization</h3>\n<p>Before moving on to coding, we must differentiate between authentication and authorization. While they sound similar, they do not mean the same thing. Authentication means we take a username and a password and check if they are correct. Authorization on the other hand is used for verifying any subsequent request to make sure they are originating from the same user we logged\u00a0in.</p>\n<h3>Middleware</h3>\n<p>To validate a token, the best approach is to write a middleware which do this validation for us and then pass the request to the next request handler if it\u2019s valid, otherwise if a token is not valid\u00a0, the middleware shall throw back some error and stops the execution. <br>We pass this middleware in api routes to make it secure. Lets understand all this with some\u00a0example</p>\n<p>In my case I get JWT token from my AWS Cognito. For those who are not familiar of AWS Cognito, It\u2019s an OAuth strategy provided by aws to authenticate an user and return a token after valid authentication. <br>Every token generated has a life span after which the token is expired and is of no use. In that case user session must be refreshed to get a new\u00a0token.</p>\n<p>Each token have an issue time and expiry time. We can use this time to check if our token is expired our not. Another approach is to cross check the signature of passed token in header with the public key provided by every OAuth strategy (in our case its AWS Cognito) to sign these\u00a0token.</p>\n<h4>Token Validator function</h4>\n<a href=\"https://medium.com/media/1f88473c0f8cb3e5d93747d68b4cbb30/href\">https://medium.com/media/1f88473c0f8cb3e5d93747d68b4cbb30/href</a><p>Above piece of code is called in the below piece of code on line no\u00a09.</p>\n<h4>Secure Middleware (important piece of\u00a0code)</h4>\n<a href=\"https://medium.com/media/f34b3610e058cb6b803e93cca0beb2d5/href\">https://medium.com/media/f34b3610e058cb6b803e93cca0beb2d5/href</a><p>On line 11 we check if our token is invalid, expired and then we throw an error which goes to express error handler and return an response like\u00a0this.</p>\n<pre>{</pre>\n<pre>    \"status\": \"ERROR\",</pre>\n<pre>    \"error\": {</pre>\n<pre>        \"code\": 400,</pre>\n<pre>        \"name\": \"BAD_REQUEST_ERROR\",</pre>\n<pre>        \"message\": \"Expired token\"</pre>\n<pre>    },</pre>\n<pre>    \"date\": \"2020-10-08T23:21:48.508Z\"</pre>\n<pre>}</pre>\n<p>If a token is valid and not expired then we can proceed with decoding the token (on line 15). Our decoded token will have fields like\u00a0this.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/433/1*pL1tiQnXz7kQrC9dIl6Agw.png\"><figcaption>decoded JWT\u00a0token</figcaption></figure><p>After everything successfully done we can either attach these fields in our response body and pass it to our api routes which will use these key value of token or we can directly call next() to pass our next request handler which are api routes in our\u00a0case.</p>\n<p>Now comes the final phase which is attaching our Secure Middleware in our api\u00a0routes.</p>\n<pre>app.get('/', secureMiddleware,</pre>\n<pre>    async (req: Request, res: Response, next: NextFunction) =&gt; {</pre>\n<pre>    const user = res.locals.user //this comes from our<br>                                 //secure middleware(on line 16)</pre>\n<pre>    res.json(user)</pre>\n<pre>    }<br>)</pre>\n<p>Finally we have made our api routes secure which will not only protects our api from unauthorized users but will also check for token\u2019s expiry to make it more secure from session hijacking.</p>\n<p>There will be a part2 of this article where we will see how to restrict access to our routes according to Users role (eg. Admin, Customer, Developer etc.)</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=fb4d71313001\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["jwt","cognito","nodejs","expressjs","api"]},{"title":"REACT JS LIFECYCLE","pubDate":"2020-05-13 17:53:59","link":"https://medium.com/@jaychaturvedi18/react-js-lifecycle-6727bd2cf82c?source=rss-74ceb30109d2------2","guid":"https://medium.com/p/6727bd2cf82c","author":"Jay Chaturvedi","thumbnail":"","description":"\n<h3>Four phases of a React component</h3>\n<p>The React component, like anything else in the world, goes through the following phases</p>\n<ul>\n<li><strong>Initialization</strong></li>\n<li><strong>Mounting</strong></li>\n<li><strong>Update</strong></li>\n<li><strong>Unmounting</strong></li>\n</ul>\n<p>The following image is the visual representation of the phases and the methods of ReactJs lifecycle.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Gl8VbwsXmNxUAjmHNZuXxg.png\"></figure><p><em>Hooks are something that let you write Functional Components and still hook into class-based features and use\u00a0them.</em></p>\n<p><strong>componentWillMount </strong>is executed just before the React Component is about to mount on the DOM. Hence, after this method the component <strong>will </strong>mount. All the things that you want to do before a component mounts has to be defined here.<br> This method is executed once in a lifecycle of a component and before first render.<br><strong>Usage: </strong>componentWillMount is used for initializing the states or props, there is a huge debate going on to merge it with the constructor.</p>\n<ul><li>\n<strong>render </strong>mounts the component onto the browser. This is a pure method, which means it gives the same output every time the same input is provided.</li></ul>\n<p><strong>componentWillMount </strong>is executed just before the React Component is about to mount on the DOM. Hence, after this method the component <strong>will </strong>mount. All the things that you want to do before a component mounts has to be defined here.<br> This method is executed once in a lifecycle of a component and before first render.<br><strong>Usage: </strong>componentWillMount is used for initializing the states or props, there is a huge debate going on to merge it with the constructor.</p>\n<ul><li>\n<strong>render </strong>mounts the component onto the browser. This is a pure method, which means it gives the same output every time the same input is provided.</li></ul>\n<p><strong>shouldComponentUpdate </strong>tells the React that when the component receives new props or state is being updated, should React re-render or it can skip rendering? <em>This method return true or\u00a0false</em></p>\n<p><em>This method is generally used when rendering is a very heavy method, then you should avoid render every now and\u00a0then.</em></p>\n<ul>\n<li>\n<strong>componentWillUpdate </strong>is executed only after the shouldComponentUpdate returns true. This method is only used to do the preparation for the upcoming render, similar to componentWillMount or constructor.<br> There can be some use case when there needs some calculation or preparation before rendering some item, this is the place to do so and then the component gets rendered.</li>\n<li>\n<strong>componentDidUpdate </strong>is executed when the new updated component has been updated in the DOM. This method is used to re trigger the third party libraries used to make sure these libraries also update and reload themselves.</li>\n</ul>\n<p><strong>componentWillUnmount </strong>This method is the last method in the lifecycle. This is executed just before the component gets removed from the\u00a0DOM.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6727bd2cf82c\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Four phases of a React component</h3>\n<p>The React component, like anything else in the world, goes through the following phases</p>\n<ul>\n<li><strong>Initialization</strong></li>\n<li><strong>Mounting</strong></li>\n<li><strong>Update</strong></li>\n<li><strong>Unmounting</strong></li>\n</ul>\n<p>The following image is the visual representation of the phases and the methods of ReactJs lifecycle.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Gl8VbwsXmNxUAjmHNZuXxg.png\"></figure><p><em>Hooks are something that let you write Functional Components and still hook into class-based features and use\u00a0them.</em></p>\n<p><strong>componentWillMount </strong>is executed just before the React Component is about to mount on the DOM. Hence, after this method the component <strong>will </strong>mount. All the things that you want to do before a component mounts has to be defined here.<br> This method is executed once in a lifecycle of a component and before first render.<br><strong>Usage: </strong>componentWillMount is used for initializing the states or props, there is a huge debate going on to merge it with the constructor.</p>\n<ul><li>\n<strong>render </strong>mounts the component onto the browser. This is a pure method, which means it gives the same output every time the same input is provided.</li></ul>\n<p><strong>componentWillMount </strong>is executed just before the React Component is about to mount on the DOM. Hence, after this method the component <strong>will </strong>mount. All the things that you want to do before a component mounts has to be defined here.<br> This method is executed once in a lifecycle of a component and before first render.<br><strong>Usage: </strong>componentWillMount is used for initializing the states or props, there is a huge debate going on to merge it with the constructor.</p>\n<ul><li>\n<strong>render </strong>mounts the component onto the browser. This is a pure method, which means it gives the same output every time the same input is provided.</li></ul>\n<p><strong>shouldComponentUpdate </strong>tells the React that when the component receives new props or state is being updated, should React re-render or it can skip rendering? <em>This method return true or\u00a0false</em></p>\n<p><em>This method is generally used when rendering is a very heavy method, then you should avoid render every now and\u00a0then.</em></p>\n<ul>\n<li>\n<strong>componentWillUpdate </strong>is executed only after the shouldComponentUpdate returns true. This method is only used to do the preparation for the upcoming render, similar to componentWillMount or constructor.<br> There can be some use case when there needs some calculation or preparation before rendering some item, this is the place to do so and then the component gets rendered.</li>\n<li>\n<strong>componentDidUpdate </strong>is executed when the new updated component has been updated in the DOM. This method is used to re trigger the third party libraries used to make sure these libraries also update and reload themselves.</li>\n</ul>\n<p><strong>componentWillUnmount </strong>This method is the last method in the lifecycle. This is executed just before the component gets removed from the\u00a0DOM.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6727bd2cf82c\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["react","reactjs","react-component-lifecycle"]},{"title":"A Brief introduction to Django MVT framework","pubDate":"2019-07-31 19:00:45","link":"https://medium.com/@jaychaturvedi18/a-brief-introduction-to-django-mvt-framework-8ef46cc321ab?source=rss-74ceb30109d2------2","guid":"https://medium.com/p/8ef46cc321ab","author":"Jay Chaturvedi","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*dxI_jUovEidZz3C2_KntVA.png\"></figure><p>This post is about giving you an idea about what is a web-framework and how it is used to make a web application.</p>\n<h4>What Are Web Frameworks:</h4>\n<p>A web framework is a software tool that provides a way to build and run web applications. As a result, you don\u2019t need to write code on your own and waste time looking for possible miscalculations and bugs. A web-framework have a basic model view controller architecture software design pattern for developing web applications, but django is a bit different in a good way. It implements concept of <strong>Model-View-Template (MVT). MVT </strong>is slightly different from <strong>MVC</strong>. In fact the main difference between the two patterns is that <strong>Django </strong>itself takes care of the Controller part (Software Code that controls the interactions between the Model and View), leaving us with the template. The template is a HTML file mixed with <strong>Django Template Language\u00a0(DTL)</strong>.</p>\n<p>For reference\u00a0: <a href=\"https://docs.djangoproject.com/en/2.2/ref/templates/language/\">https://docs.djangoproject.com/en/2.2/ref/templates/language/</a></p>\n<h4><strong>What is MVT (Model, View, and Template)</strong></h4>\n<p>To understand MVT, think Model as a Logical data structure. It is the middleware &amp; data handler between database and view. The Model provides a definition of how the data formats as coming from the view so, it stores in the database and vice-versa, i.e., the retrieving information from the database transfers to the view in the displayable format.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*5tlbCdsQHDW38Yn1eP97Kg.png\"><figcaption>Django\u2019s MVT flow. Here django itself is working as controller</figcaption></figure><p>Views receive data as well as request method (\u201cPOST\u201d,\u201dGET\u201d) from client side and accordingly formats the data via model so that it can be stored in database. It also communicates to the database for retrieving data which transfer to the template for\u00a0viewing.</p>\n<p>Django needs a convenient way to generate HTML dynamically. The most common approach relies on templates. A template contains the static parts of the desired HTML output as well as some special syntax describing how dynamic content will be inserted. Template provides much more extendibility to the frontend developers than what MVC architecture was giving. One template can be used by different views to show various formats of data. It keeps all the content that is rendered by the browser. This part is what is visible to the client side. Model &amp; views reside on the server\u00a0side.</p>\n<h4><strong>Working with\u00a0Django</strong></h4>\n<p>\u201cdjango-admin startproject projectname\u201d creates a root folder with the project name you provided including all the basic files needed to launch your basic application. Just type \u201cpython manage.py runserver\u201d in the terminal to runserver for your application.</p>\n<pre>projectname/manage.py<br>            projectname/<br>                   __init__.py<br>                   settings.py<br>                   urls.py<br>                   wsgi.py<br>                   views.py</pre>\n<p>Django plays the crucial role of managing HTTP responses and request. So when a template request an update data on the client side, request and data is seen by views on the server side. then it transports to the correct\u00a0URL.</p>\n<p>The URL mapping in Django is easy to map and attach template with every\u00a0url.</p>\n<p>It is actually done in regular expressions and the arguments for URL are passed\u00a0in</p>\n<p>path(\u201curl name/\u201d, \u201cfunction name\u201d, name = \u201coptional\u201d).</p>\n<p>These expressions are much more understandable than IP addresses.</p>\n<pre>url patterns = [<br>path(\u201c\u201c, views.index, name = \u201chome\u201d),<br>path(\u201ccontact/\u201d, views.contact, name = \u201ccontact\u201d),<br>path(\u201cabout/\u201d, views.about, name = \u201cabout\u201d)]</pre>\n<p>When we request for the website, the interface through which we use to make that request via our browser was the Template. Then that request transmits to the server for the management of view\u00a0file</p>\n<p>Suppose \u201c<a href=\"https://medium.com/www.yourblog.com\">www.yourblog.com</a>\u201d is website\u2019s default url, It will open the home page. When you request to navigate to \u201ccontact/\u201d page, path will know how to handle that and you don\u2019t to specify it explicitly. In this case the path will return path will have information of the url to that page and you don\u2019t to specify it explicitly.</p>\n<p>In this case the path will return w<a href=\"http://www.yourblog.com/contact.html\">ww.yourblog.com/contact.html</a>\u00a0, it calls views.contact() function defined in views.py. This function render the HTML template page for this URL path which then will be displayed on the client side. You can set a name for this url pattern, its optional but I recommend you to name each path, because for complex websites with multiple pages, the url patterns can become really messy real\u00a0quick.</p>\n<p>For reference: <a href=\"https://docs.djangoproject.com/en/2.2/ref/urls/\">https://docs.djangoproject.com/en/2.2/ref/urls/</a></p>\n<p>Now after the sending of a request to the correct URL, the app logic applies and the model initiates to correct response to the given request. Then that particular response is sent back to the View where it again examines the response and transmits it as an HTTP response or desired user format. Then, it again renders by the browser via Templates, one of the important components of Django MTV architecture.</p>\n<p>An easier real-life working of above functioning would be\u00a0\u2013</p>\n<p>When you login in a website (<a href=\"https://www.djangoproject.com/start/?source=post_page---------------------------\">Django</a> based), you open the login page. It again happens without the need of the Model. It is because Views will process the request and send it to the URL of the login page. Then, it will be a response by the server, from there to the\u00a0browser.</p>\n<p>After that, you enter your credentials in the given Template, HTML form. From there the data is again sent to the view, this time this request rectifies and the model is given data. Then the Model reads and verifies the data that the user provides within the connected database.</p>\n<p>If the user data matches it will send the relevant user data like profile image, name and (other things depending on the type of website) to the Views. It will then format the same in desired response and will transmit the same to the\u00a0client.</p>\n<p>Otherwise, the Model will send a negative result to the Views. In turn, it will rout it to the login page again alongside an error\u00a0message.</p>\n<p>That\u2019s how the Django MVT architecture is actually\u00a0working.</p>\n<p>Thanks for bearing with me, I hope this gave you an insight about django and helped you to understand how its actually managing the application in a nice clean structure.</p>\n<p>It\u2019s not just Django, you can use Flask framework as well. It\u2019s all upto choice of what size of application and how fast you want to\u00a0make.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8ef46cc321ab\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*dxI_jUovEidZz3C2_KntVA.png\"></figure><p>This post is about giving you an idea about what is a web-framework and how it is used to make a web application.</p>\n<h4>What Are Web Frameworks:</h4>\n<p>A web framework is a software tool that provides a way to build and run web applications. As a result, you don\u2019t need to write code on your own and waste time looking for possible miscalculations and bugs. A web-framework have a basic model view controller architecture software design pattern for developing web applications, but django is a bit different in a good way. It implements concept of <strong>Model-View-Template (MVT). MVT </strong>is slightly different from <strong>MVC</strong>. In fact the main difference between the two patterns is that <strong>Django </strong>itself takes care of the Controller part (Software Code that controls the interactions between the Model and View), leaving us with the template. The template is a HTML file mixed with <strong>Django Template Language\u00a0(DTL)</strong>.</p>\n<p>For reference\u00a0: <a href=\"https://docs.djangoproject.com/en/2.2/ref/templates/language/\">https://docs.djangoproject.com/en/2.2/ref/templates/language/</a></p>\n<h4><strong>What is MVT (Model, View, and Template)</strong></h4>\n<p>To understand MVT, think Model as a Logical data structure. It is the middleware &amp; data handler between database and view. The Model provides a definition of how the data formats as coming from the view so, it stores in the database and vice-versa, i.e., the retrieving information from the database transfers to the view in the displayable format.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*5tlbCdsQHDW38Yn1eP97Kg.png\"><figcaption>Django\u2019s MVT flow. Here django itself is working as controller</figcaption></figure><p>Views receive data as well as request method (\u201cPOST\u201d,\u201dGET\u201d) from client side and accordingly formats the data via model so that it can be stored in database. It also communicates to the database for retrieving data which transfer to the template for\u00a0viewing.</p>\n<p>Django needs a convenient way to generate HTML dynamically. The most common approach relies on templates. A template contains the static parts of the desired HTML output as well as some special syntax describing how dynamic content will be inserted. Template provides much more extendibility to the frontend developers than what MVC architecture was giving. One template can be used by different views to show various formats of data. It keeps all the content that is rendered by the browser. This part is what is visible to the client side. Model &amp; views reside on the server\u00a0side.</p>\n<h4><strong>Working with\u00a0Django</strong></h4>\n<p>\u201cdjango-admin startproject projectname\u201d creates a root folder with the project name you provided including all the basic files needed to launch your basic application. Just type \u201cpython manage.py runserver\u201d in the terminal to runserver for your application.</p>\n<pre>projectname/manage.py<br>            projectname/<br>                   __init__.py<br>                   settings.py<br>                   urls.py<br>                   wsgi.py<br>                   views.py</pre>\n<p>Django plays the crucial role of managing HTTP responses and request. So when a template request an update data on the client side, request and data is seen by views on the server side. then it transports to the correct\u00a0URL.</p>\n<p>The URL mapping in Django is easy to map and attach template with every\u00a0url.</p>\n<p>It is actually done in regular expressions and the arguments for URL are passed\u00a0in</p>\n<p>path(\u201curl name/\u201d, \u201cfunction name\u201d, name = \u201coptional\u201d).</p>\n<p>These expressions are much more understandable than IP addresses.</p>\n<pre>url patterns = [<br>path(\u201c\u201c, views.index, name = \u201chome\u201d),<br>path(\u201ccontact/\u201d, views.contact, name = \u201ccontact\u201d),<br>path(\u201cabout/\u201d, views.about, name = \u201cabout\u201d)]</pre>\n<p>When we request for the website, the interface through which we use to make that request via our browser was the Template. Then that request transmits to the server for the management of view\u00a0file</p>\n<p>Suppose \u201c<a href=\"https://medium.com/www.yourblog.com\">www.yourblog.com</a>\u201d is website\u2019s default url, It will open the home page. When you request to navigate to \u201ccontact/\u201d page, path will know how to handle that and you don\u2019t to specify it explicitly. In this case the path will return path will have information of the url to that page and you don\u2019t to specify it explicitly.</p>\n<p>In this case the path will return w<a href=\"http://www.yourblog.com/contact.html\">ww.yourblog.com/contact.html</a>\u00a0, it calls views.contact() function defined in views.py. This function render the HTML template page for this URL path which then will be displayed on the client side. You can set a name for this url pattern, its optional but I recommend you to name each path, because for complex websites with multiple pages, the url patterns can become really messy real\u00a0quick.</p>\n<p>For reference: <a href=\"https://docs.djangoproject.com/en/2.2/ref/urls/\">https://docs.djangoproject.com/en/2.2/ref/urls/</a></p>\n<p>Now after the sending of a request to the correct URL, the app logic applies and the model initiates to correct response to the given request. Then that particular response is sent back to the View where it again examines the response and transmits it as an HTTP response or desired user format. Then, it again renders by the browser via Templates, one of the important components of Django MTV architecture.</p>\n<p>An easier real-life working of above functioning would be\u00a0\u2013</p>\n<p>When you login in a website (<a href=\"https://www.djangoproject.com/start/?source=post_page---------------------------\">Django</a> based), you open the login page. It again happens without the need of the Model. It is because Views will process the request and send it to the URL of the login page. Then, it will be a response by the server, from there to the\u00a0browser.</p>\n<p>After that, you enter your credentials in the given Template, HTML form. From there the data is again sent to the view, this time this request rectifies and the model is given data. Then the Model reads and verifies the data that the user provides within the connected database.</p>\n<p>If the user data matches it will send the relevant user data like profile image, name and (other things depending on the type of website) to the Views. It will then format the same in desired response and will transmit the same to the\u00a0client.</p>\n<p>Otherwise, the Model will send a negative result to the Views. In turn, it will rout it to the login page again alongside an error\u00a0message.</p>\n<p>That\u2019s how the Django MVT architecture is actually\u00a0working.</p>\n<p>Thanks for bearing with me, I hope this gave you an insight about django and helped you to understand how its actually managing the application in a nice clean structure.</p>\n<p>It\u2019s not just Django, you can use Flask framework as well. It\u2019s all upto choice of what size of application and how fast you want to\u00a0make.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8ef46cc321ab\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["django","python","web-framework","web-development"]}]}